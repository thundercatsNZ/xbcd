/*	
    Copyright 2005 Helder Acevedo

    This file is part of XBCD.

    XBCD is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    XBCD is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with XBCD; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "XBCD_driver.h"

/*!
Report descriptor (describes the meaning of each bit in the data
packet generated by this driver) 
For HID/'usages'/etc. documentation the best place to start is
www.usb.org

'Read' this list from top to bottom, i.e. any value that's set is in
effect until it's being overwritten. For example setting the report field
size to 10 bits, like this:
...
0x75, 0x0a,    /* report size (10) => 10 bits * /
...
will let you generate 10 bit fields until the next size is set, e.g.:
...
0x75, 0x10,    /* report size (16) => 16 bits * /
...

This 'rule' of course applies to other items than the report field size,
for example setting the report count (i.e. the number of fields to
generate) to 2 like this:
...
0x95, 0x02,    /* report count (2) => two fields * /
...
will generate always two fields of what comes next, for example, if
the following line would be 
0x81, 0x02,    /* input (data, var, abs) * /
then TWO input fields (of the last specified bit width) will be defined.

Then of course TWO usage descriptions for these field are necessary, e.g.:
...
0x09, 0x30,    /* usage (x) * /
0x09, 0x31,    /* usage (y) * /
...

NOTE: The descriptions alone do not define the fields! (In this example it's
done by the line that says 'input (data, var, abs)'


The data structure described here looks like this:

Input
------

Byte   : Bit 7   6   5   4   3   2   1   0 | 7   6   5   4   3   2   1   0
[0]    :   |           Report ID           |
[1]    :   |B8 |B7 |B6 |B5 |B4 |B3 |B2 |B1 |
[2]    :   |B16|B15|B14|B13|B12|B11|B10|B9 |
[3]    :   |B24|B23|B22|B21|B20|B19|B18|B17|
[4-5]  :   |                            X Axis                             |
[6-7]  :   |                            Y Axis                             |
[8-9]  :   |                            Z Axis                             |
[10-11] :  |                            RX Axis                            |
[12-13]:   |                            RY Axis                            |
[14-15]:   |                            RZ Axis                            |
[16-17]:   |                          Slider Axis                          |
[18]   :   |     EMPTY     |      POV      |
[19]   :   |       Current MapMatrix       |
--- Original data from Xbox controller ---
[20]   :   |             0x00              |
[21]   :   |      0x14(Size of report)     |
[22]   :   |RSp|LSp|Bk |St |Rgt|Lft|Dn |Up |
[23]   :   |             0x00              |
[24]   :   |           Button A            |
[25]   :   |           Button B            |
[26]   :   |           Button X            |
[27]   :   |           Button Y            |
[28]   :   |         Button Black          |
[29]   :   |         Button White          |
[30]   :   |         Left Trigger          |
[31]   :   |         Right Trigger         |
[32-33]:   |                         Left-Stick X                          |
[34-35]:   |                         Left-Stick Y                          |
[36-37]:   |                         Right-Stick X                         |
[38-39]:   |                         Right-Stick Y                         |

Output
-------

Byte   : Bit 7   6   5   4   3   2   1   0 |
[0]    :   |           Report ID           |
[1]    :   |         Left Actuator         |
[2]    :   |         Right Actuator        |

Feature
-------

Byte   : Bit 7   6   5   4   3   2   1   0 |
[0]    :   |           Report ID           |
[1]    :   |        Signature 1 (X)        |
[2]    :   |        Signature 2 (B)        |
[3]    :   |        Signature 3 (S)        |
[4]    :   |        Signature 4 (U)        |

Feature
-------

Byte   : Bit 7   6   5   4   3   2   1   0 |
[0]    :   |           Report ID           |
[1]    :   |        Signature 1 (X)        |
[2]    :   |        Signature 2 (B)        |
[3]    :   |        Signature 3 (S)        |
[4]    :   |        Signature 4 (U)        |
[5]    :   |        Version: Major         |
[6]    :   |        Version: Minor         |
[7]    :   |       Version: Release        |

*/

UCHAR RD1[]=
{
	0xa1, 0x01,			//     COLLECTION (Application)
	0xa1, 0x02,			//     COLLECTION (Logical)
	0x85, 0x01,			//     REPORT_ID (1)

	0x05, 0x09,			//     USAGE_PAGE (Button)
	0x15, 0x00,			//     LOGICAL_MINIMUM (0)
	0x25, 0x01,			//     LOGICAL_MAXIMUM (1)
	0x35, 0x00,			//     PHYSICAL_MINIMUM (0)
	0x45, 0x01			//     PHYSICAL_MAXIMUM (1)
};


UCHAR RD2[]=
{
	/*!
	Somehow each axis that's taken from the generic desktop usage page has
	to have a matching entry in the registry (or at least it seems to be
	like that, good grief!). If the entry does not exist, the gamepad is
	still recognized, but when entering its 'Properties' from 'Gaming
	options' in the control panel, an error message will pop up
	('Device not connected'...).
	For axes taken from the simulation controls usage page no registry
	entry has to exist (...but why?)

	Furthermore, the axis definitions have to be in a certain order, which is
	X, Y, Z, R, U, V (Rz maps to R, Slider maps to U, Rx maps to V).
	
	NOTE: The entries in the registry are apparently used for 'axis mapping',
	i.e. to change the default mapping described above. This is not necessary
	with this driver and in fact even caused a problem of one axis being lost
	after rebooting.
	*/

	/*!
	Axes definitions (X, Y, Z, Rz, Slider, Rx, Ry)
	All axis types are from the generic desktop usage page.
	*/
    0x75, 0x10,			//     REPORT_SIZE (16)
    0x16, 0x01, 0x80,	//     LOGICAL_MINIMUM (-32767)
    0x26, 0xff, 0x7f,	//     LOGICAL_MAXIMUM (32767)
    0x35, 0x00,			//     PHYSICAL_MINUMUM (0)
    0x46, 0xff, 0x7f,	//     PHYSICAL_MAXIMUM (32767)

    0x05, 0x01,			//     USAGE_PAGE (Generic Desktop)
    0x95, 0x07,			//     REPORT_COUNT (7) => seven fields (...of the above defined 16 bits)
    0x09, 0x30,			//     USAGE (X)
    0x09, 0x31			//     USAGE (Y)
};

//Array of axes which can be turned off
UCHAR RDA[5][2]=
{
	0x09, 0x32,			//     USAGE (Z)
	0x09, 0x33,			//     USAGE (Rx) - usage page 1 generic desktop
	0x09, 0x34,			//     USAGE (Ry) - usage page 1 generic desktop
	0x09, 0x35,			//     USAGE (Rz) - usage page 1 generic desktop
	0x09, 0x36			//     USAGE (Slider) - usage page 1 generic desktop
};

//Any axis turned off is replaced by this in the
//report descriptor
UCHAR RDACB[]=
{
	0x09, 0x3A			//     USAGE (Counted Buffer) - usage page 1 generic desktop
};

UCHAR RD3[]=
{
    0x81, 0x02,			//     INPUT (Data,Var,Abs)

	// 4 Bits for the POV hat switch
    0x05, 0x01,			//     USAGE_PAGE (Generic Desktop)
    0x09, 0x39,			//     USAGE (Hat switch)
    0x15, 0x00,			//     LOGICAL_MINIMUM (0)
    0x25, 0x07,			//     LOGICAL_MAXIMUM (7)
    0x35, 0x00,			//     PHYSICAL_MINIMUM (0)
    0x46, 0x3b,0x01,	//     PHYSICAL_MAXIMUM (315)
    0x65, 0x14,			//     UNIT (Eng Rot:Angular Pos)
    0x75, 0x04,			//     REPORT_SIZE (4)
    0x95, 0x01,			//     REPORT_COUNT (1)
    0x81, 0x02,			//     INPUT (Data,Var,Abs)

	/*!
	Actually another POV would be cool. Maybe later? But the older multimedia
	APIs (e.g. in Win98) do not accept two POVs. So, let's fill the 4 empty
	bits for now...
	*/
	0x75, 0x04,			//     REPORT_SIZE (4)
	0x95, 0x01,			//     REPORT_COUNT (1)
	0x81, 0x01,			//     INPUT (Cnst,Ary,Abs)

	/*
	21 bytes. The first indicates the selected MapMatrix.  The other 20 contain
	the original data from the Xbox controller.  Used in the setup utility for testing.
	*/
	0x05, 0x01,			//     USAGE_PAGE (Generic Desktop)
    0x09, 0x3A,			//     USAGE (Counted Buffer)
	0x75, 0xA8,			//     REPORT_SIZE (168)
    0x95, 0x01,			//     REPORT_COUNT (1)
    0x81, 0x02,			//     INPUT (Data,Var,Abs)
	0xc0,				//     END_COLLECTION

	/*!
	Two 8 Bit outputs (i.e. data goes TO the driver).
	The first byte controls the left rumble actuator and the second
	controls the right actuator.
	*/
	0xa1, 0x02,			//     COLLECTION (Logical)
	0x85, 0x02,			//     REPORT_ID (2)
	0x05, 0x00,			//     USAGE_PAGE (Not Defined)
    0x15, 0x00,			//     LOGICAL_MINIMUM (0)
    0x26, 0xff, 0x00,	//     LOGICAL_MAXIMUM (255)
    0x35, 0x00,			//     PHYSICAL_MINIMUM (0)
    0x46, 0xff, 0x00,	//     PHYSICAL_MAXIMUM (255)
    0x75, 0x08,			//     REPORT_SIZE (8)
    0x95, 0x02,			//     REPORT_COUNT (2)
    0x09, 0x00,			//     USAGE (Undefined)
    0x09, 0x01,			//     USAGE (Undefined)
    0x91, 0x02,			//     OUTPUT (Data,Var,Abs)
	0xc0,				//     END_COLLECTION

	/*
	This feature report is used to tell the driver to read the
	configuration from the registry.  The driver receives a
	4 byte buffer which must contain the signature "XBSU" for
	the request to be processed.
	*/
	0xa1, 0x02,			//     COLLECTION (Logical)
	0x85, 0x03,			//     REPORT_ID (3)
	0x15, 0x00,			//     LOGICAL_MINIMUM (0)
    0x25, 0xff,			//     LOGICAL_MAXIMUM (-1)
    0x35, 0x00,			//     PHYSICAL_MINIMUM (0)
    0x45, 0xff,			//     PHYSICAL_MAXIMUM (-1)
    0x75, 0x20,			//     REPORT_SIZE (32)
    0x95, 0x01,			//     REPORT_COUNT (1)
    0x05, 0x00,			//     USAGE_PAGE (Not Defined)
    0x09, 0x00,			//     USAGE (Undefined)
    0xb1, 0x02,			//     FEATURE (Data,Var,Abs)
	0xc0,				//     END_COLLECTION
	0xa1, 0x02,			//     COLLECTION (Logical)
	0x85, 0x04,			//     REPORT_ID (4)
	0x15, 0x00,			//     LOGICAL_MINIMUM (0)
    0x25, 0xff,			//     LOGICAL_MAXIMUM (-1)
    0x35, 0x00,			//     PHYSICAL_MINIMUM (0)
    0x45, 0xff,			//     PHYSICAL_MAXIMUM (-1)
    0x75, 0x20,			//     REPORT_SIZE (56)
    0x95, 0x01,			//     REPORT_COUNT (1)
    0x05, 0x00,			//     USAGE_PAGE (Not Defined)
    0x09, 0x00,			//     USAGE (Undefined)
    0xb1, 0x02,			//     FEATURE (Data,Var,Abs)
	0xc0,				//     END_COLLECTION

    0xc0				//     END_COLLECTION
};

// from free60.org cvs
UCHAR RDX360[]=
{
	0xa1, 0x01,			// COLLECTION (Application)
	// Unused
	0x75, 0x08,			//  REPORT SIZE (8)
	0x95, 0x01,			//  REPORT COUNT (1)
	0x81, 0x01,			//  INPUT (Constant)
	// Byte count
	0x75, 0x08,			//  REPORT SIZE (8)
	0x95, 0x01,			//  REPORT COUNT (1)
	0x05, 0x01,			//  USAGE PAGE (Generic Desktop)
	0x09, 0x3b,			//  USAGE (Byte Count)
	0x81, 0x01,			//  INPUT (Constant)
	// D-Pad
	0x05, 0x01,			//  USAGE PAGE (Generic Desktop)
	0x09, 0x01,			//  USAGE (Pointer)
	0xa1, 0x00,			//  COLLECTION (Physical)
	0x75, 0x01,			//   REPORT SIZE (1)
	0x15, 0x00,			//   LOGICAL MINIMUM (0)
	0x25, 0x01,			//   LOGICAL MAXIMUM (1)
	0x35, 0x00,			//   PHYSICAL MINIMUM (0)
	0x45, 0x01,			//   PHYSICAL MAXIMUM (1)
	0x95, 0x04,			//   REPORT COUNT (4)
	0x05, 0x01,			//   USAGE PAGE (Generic Desktop)
	0x09, 0x90,			//   USAGE (D-Pad Up)
	0x09, 0x91,			//   USAGE (D-Pad Down)
	0x09, 0x93,			//   USAGE (D-Pad Left)
	0x09, 0x92,			//   USAGE (D-Pad Right)
	0x81, 0x02,			//   INPUT (Data, Variable, Absolute)
	0xc0,				//  END COLLECTION
	// Buttons 5-11
	0x75, 0x01,			//  REPORT SIZE (1)
	0x15, 0x00,			//  LOGICAL MINIMUM (0)
	0x25, 0x01,			//  LOGICAL MAXIMUM (1)
	0x35, 0x00,			//  PHYSICAL MINIMUM (0)
	0x45, 0x01,			//  PHYSICAL MAXIMUM (1)
	0x95, 0x07,			//  REPORT COUNT (7)
	0x05, 0x09,			//  USAGE PAGE (Button)
	0x09, 0x08,			//  USAGE (Button 8)
	0x09, 0x07,			//  USAGE (Button 7)
	0x09, 0x09,			//  USAGE (Button 9)
	0x09, 0x0a,			//  USAGE (Button 10)
	0x09, 0x05,			//  USAGE (Button 5)
	0x09, 0x06,			//  USAGE (Button 6)
	0x09, 0x0b,			//  USAGE (Button 11)
	0x81, 0x02,			//  INPUT (Data, Variable, Absolute)
	// Unused
	0x75, 0x01,			//  REPORT SIZE (1)
	0x95, 0x01,			//  REPORT COUNT (1)
	0x81, 0x01,			//  INPUT (Constant)
	// Buttons 1-4
	0x75, 0x01,			//  REPORT SIZE (1)
	0x15, 0x00,			//  LOGICAL MINIMUM (0)
	0x25, 0x01,			//  LOGICAL MAXIMUM (1)
	0x35, 0x00,			//  PHYSICAL MINIMUM (0)
	0x45, 0x01,			//  PHYSICAL MAXIMUM (1)
	0x95, 0x04,			//  REPORT COUNT (4)
	0x05, 0x09,			//  USAGE PAGE (Button)
	0x19, 0x01,			//  USAGE MINIMUM (Button 1)
	0x29, 0x04,			//  USAGE MAXIMUM (Button 4)
	0x81, 0x02,			//  INPUT (Data, Variable, Absolute)
	// Triggers
	0x75, 0x08,			//  REPORT SIZE (8)
	0x15, 0x00,			//  LOGICAL MINIMUM (0)
	0x26, 0xff, 0x00,	//  LOGICAL MAXIMUM (255)
	0x35, 0x00,			//  PHYSICAL MINIMUM (0)
	0x46, 0xff, 0x00,	//  PHYSICAL MAXIMUM (255)
	0x95, 0x02,			//  REPORT SIZE (2)
	0x05, 0x01,			//  USAGE PAGE (Generic Desktop)
	0x09, 0x32,			//  USAGE (Z)
	0x09, 0x35,			//  USAGE (Rz)
	0x81, 0x02,			//  INPUT (Data, Variable, Absolute)
	// Sticks
	0x75, 0x10,			//  REPORT SIZE (16)
	0x16, 0x00, 0x80,	//  LOGICAL MINIMUM (-32768)
	0x26, 0xff, 0x7f,	//  LOGICAL MAXIMUM (32767)
	0x36, 0x00, 0x80,	//  PHYSICAL MINIMUM (-32768)
	0x46, 0xff, 0x7f,	//  PHYSICAL MAXIMUM (32767)
	0x95, 0x04,			//  REPORT COUNT (4)
	0x05, 0x01,			//  USAGE PAGE (Generic Desktop)
	0x09, 0x30,			//  USAGE (X)
	0x09, 0x31,			//  USAGE (Y)
	0x09, 0x33,			//  USAGE (Rx)
	0x09, 0x34,			//  USAGE (Ry)
	0x81, 0x02,			//  INPUT (Data, Variable, Absolute)
	// Unused
	0x75, 0x30,			//  REPORT SIZE (48)
	0x95, 0x01,			//  REPORT COUNT (1)
	0x81, 0x01,			//  INPUT (Constant)
	0xc0,				// END COLLECTION
};

USHORT GetRepDesc(PDEVICE_EXTENSION pDevExt, PUCHAR Buffer)
{
	USHORT size;

	UCHAR RDU[]=
	{
		0x05, 0x01,									// USAGE_PAGE (Generic Desktop)
		0x09, pDevExt->DevUsage						// USAGE (Gamepad or Joystick)
	};

	UCHAR RDB[]=
	{
		0x19, 0x01,									//     USAGE_MININUM (Button 1)
		0x29, pDevExt->nButtons,					//     USAGE_MAXIMUM (Max 24 buttons)
		0x75, 0x01,									//     REPORT_SIZE (1)
		0x95, pDevExt->nButtons,					//     REPORT_COUNT (Max 24 buttons)
		0x81, 0x02									//     INPUT (Data,Var,Abs)
	};

	UCHAR RDBCB[]=
	{
		0x05, 0x01,									//     USAGE_PAGE (Generic Desktop)
		0x09, 0x3A,									//     USAGE (Counted Buffer)
		0x75, (NR_OUT_BUTTONS-pDevExt->nButtons),	//     REPORT_SIZE (24-#buttons)
		0x95, 0x01,									//     REPORT_COUNT (1)
		0x81, 0x02									//     INPUT (Data,Var,Abs)
	};

	KdPrint(("GetRepDesc - entry"));

	if(!Buffer)
	{
		size = sizeof(RDU);
#if 0
		if(pDevExt->is360)
		{
			size += sizeof(RDX360);
		}
		else
#endif
		{
			size += sizeof(RD1);
			size += sizeof(RDB);
			if(pDevExt->nButtons < NR_OUT_BUTTONS)
			{
				size += sizeof(RDBCB);
			}
			size += sizeof(RD2);
			size += sizeof(RDA);
			size += sizeof(RD3);
		}
	}
	else
	{
		int iCount;

		RtlCopyMemory(&Buffer[0], RDU, sizeof(RDU));
		size = sizeof(RDU);

#if 0
		if(pDevExt->is360)
		{
			RtlCopyMemory(&Buffer[size], RDX360, sizeof(RDX360));
			size += sizeof(RDX360);

		}
		else
#endif
		{
			RtlCopyMemory(&Buffer[size], RD1, sizeof(RD1));
			size += sizeof(RD1);

			RtlCopyMemory(&Buffer[size], RDB, sizeof(RDB));
			size += sizeof(RDB);

			if(pDevExt->nButtons < NR_OUT_BUTTONS)
			{
				RtlCopyMemory(&Buffer[size], RDBCB, sizeof(RDBCB));
				size += sizeof(RDBCB);
			}

			RtlCopyMemory(&Buffer[size], RD2, sizeof(RD2));
			size += sizeof(RD2);

			for(iCount=0; iCount<5; ++iCount)
			{
				UCHAR temp = pDevExt->AxesOn >> iCount;

				if(temp & 1)
				{
					RtlCopyMemory(&Buffer[size], RDA[iCount], sizeof(RDA[iCount]));
					size += sizeof(RDA[iCount]);
					KdPrint(("Axis %d is On", iCount));
				}
				else
				{
					RtlCopyMemory(&Buffer[size], RDACB, sizeof(RDACB));
					size += sizeof(RDACB);
					KdPrint(("Axis %d is Off", iCount));
				}
			}

			RtlCopyMemory(&Buffer[size], RD3, sizeof(RD3));
			size += sizeof(RD3);
		}
	}

	KdPrint(("GetRepDesc - Size of report descriptor = %d", size));

	KdPrint(("GetRepDesc - returning"));
	return size;
}
